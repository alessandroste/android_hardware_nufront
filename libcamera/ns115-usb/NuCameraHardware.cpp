/*
**
** Copyright 2008, The Android Open Source Project
** Copyright 2012, Nufront Co. LTD
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/
#define LOG_NDEBUG 0
#define LOG_TAG "NuCameraHardware"
#include <utils/Log.h>
#include "NuCameraHardware.h"
#include <utils/threads.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <camera/Camera.h>
//#include <media/stagefright/MetadataBufferType.h>
#include <ui/GraphicBufferMapper.h>
#include "Effect.h"
#include "Converters.h"

#include <cutils/fdt.h>
#include <HardwareRendererCamera.h>
#include <media/stagefright/MetaData.h>
#include <CameraHardwareInterface.h>

// default frame rate
#define VIDEO_BACK_FRAME_RATE 15
#define BACK_SUPPORT_FRAME_RATES "15,30"
#define VIDEO_FRONT_FRAME_RATE 15
#define FRONT_SUPPORT_FRAME_RATES "15,30"
//#define SUPPORT_RESO_SIZE 512
// default preview size
#define BACK_PREVIEW_WIDTH  640
#define BACK_PREVIEW_HEIGHT 480
//#ifdef CAMERA_OV2643
//#define FRONT_PREVIEW_WIDTH  800 //320
//#define FRONT_PREVIEW_HEIGHT 600  //240
//#else
#define FRONT_PREVIEW_WIDTH  320
#define FRONT_PREVIEW_HEIGHT 240

#define GC0308_FOCAL_LENGTH_STR            "1.82"
#define USB_FOCAL_LENGTH_STR         "3.37"

#define USB_HVIEW_ANGLE   56.3
#define USB_VVIEW_ANGLE    43.7

#define GC0308_HVIEW_ANGLE   47.8
#define GC0308_VVIEW_ANGLE    36.9

//#endif

// pixel format for preview window
#define PREVIEW_WIN_PIXEL_FMT      HAL_PIXEL_FORMAT_YCbCr_420_SP

// frame skip
#define INITIAL_SKIP_FRAME  15
#define EFFECT_SKIP_FRAME   1
#define SNAP_SKIP_FRAME     7

//get byte
#define HIBYTE(x) (((x) >> 8) & 0xFF)
#define LOBYTE(x) ((x) & 0xFF)


#define BACK_CAMERA_AUTO_FOCUS_DISTANCES_STR       "0.10,1.20,Infinity"
#define FRONT_CAMERA_FOCUS_DISTANCES_STR           "0.20,0.25,Infinity"

// FIXME:
// -- The actual preview color is set to NV21. The preview frames
//    returned via preview callback must be generated by color
//    conversion if the requested preview color format for the
//    preview frames is _not_ NV21. The reason that NV21 is used
//    for actual preview is because that is the only color format
//    supported by gralloc. Matching the preview cor format with
//    gralloc color format improves performance since no color
//    conversion is needed for preview.
//
// -- we only support two preview color formats that client
//    applications can set: NV21 and YUV420/YV12.      <============ attention !!!!!

namespace android {

struct addrs {
   uint32_t type;  // make sure that this is 4 byte.
   unsigned int addr_y;
   unsigned int addr_cbcr;
   unsigned int buf_index;
   unsigned int reserved;
};
struct addrs_cap {
   unsigned int addr_y;
   unsigned int width;
   unsigned int height;
};

gralloc_module_t const* NuCameraHardware::mGrallocHal;

NuCameraHardware::NuCameraHardware(int cameraId, camera_device_t *dev)
        :
          mParameters(),
          mInternalParameters(),
          mMsgEnabled(0),
          mSkipFrame(0),
          mLastPreviewed(0),
          mPreviewAfter(0),
          mCaptureInProgress(false),
          mPostViewWidth(0),
          mPostViewHeight(0),
          mPostViewSize(0),
          mRecordRunning(false),
          mCallbackCookie(0),
          mNotifyCb(0),
          mDataCb(0),
          mDataCbTimestamp(0),
          mPreviewHeap(NULL),
          mRawHeap(NULL),
          mRecordHeap(NULL),
          mHalDevice(dev),
          mCameraSensorName(NULL),
          isSupportFlashMode(false),
          isSupportFocusMode(false),
          isUsbCamera(false),
          isCameraFaceBack(false),
          isSupportAutoWhiteBalance(false),
          isSupportVflip(false),
          isSupportHflip(false),
          isSupportDoWhiteBalance(false),
          isSupportSpecialEffect(false),
          isSupportSetBrightness(false),
          tempWhileBalance(0)
{
    int ret = 0;
	char supportPreviewSize[SUPPORT_RESO_SIZE];

    mPreviewWindow = NULL;
    //return singleton instance
    mNuCameraV4L2 = NuCameraV4L2::createInstance();

    //get gralloc module
    if (!mGrallocHal) {
        LOGV("function: %s: hw_get_module(GRALLOC_HARDWARE_MODULE_ID)", __func__);
        ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, (const hw_module_t **)&mGrallocHal);
        if (ret)
        {
            LOGE("ERR(%s):Fail on loading gralloc HAL", __func__);
        }
    }
	memset(supportPreviewSize, sizeof(supportPreviewSize), 0);
    ret = mNuCameraV4L2->initCamera(this, cameraId, SUPPORT_RESO_SIZE);
    if ( ret < 0) {
        LOGE("ERR(%s):Fail on mNuCameraV4L2 init", __func__);
    }
    LOGI("isCameraFaceBack(%d),isUsbCamera(%d),isSupportDoWhiteBalance(%d),isSupportAutoWhiteBalance(%d),isSupportSetBrightness(%d),isSupportSpecialEffect(%d),isSupportVflip(%d),isSupportHflip(%d),isSupportFlashMode(%d),isSupportFocusMode(%d)",
		 isCameraFaceBack,isUsbCamera,isSupportDoWhiteBalance,isSupportAutoWhiteBalance,isSupportSetBrightness,isSupportSpecialEffect,isSupportVflip,isSupportHflip,isSupportFlashMode,isSupportFocusMode);

	initDefaultParameters(cameraId, SUPPORT_RESO_SIZE);

    mExitAutoFocusThread = false;
    mExitPreviewThread = false;
    /* whether the PreviewThread is active in preview or stopped.  we
     * create the thread but it is initially in stopped state.
     */
    mPreviewRunning = false;
    mPreviewStartDeferred = false;
    mPreviewThread = new PreviewThread(this);
    mAutoFocusThread = new AutoFocusThread(this);
    mCaptureThread = new CaptureThread(this);
}

int NuCameraHardware::getCameraId() const
{
    return mNuCameraV4L2->getCameraId();
}

inline void   NuCameraHardware::initCameraParameters(int size)
{
	LOGI("mVideoSize(%s),mPreviewSize(%dx%d). %s : %s", mVideoSize, mPreviewSize.width, mPreviewSize.height, __func__, supportPreviewSize);

	CameraParameters p;
	p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, supportPreviewSize);
	p.set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, supportPreviewSize);
    p.set(CameraParameters::KEY_SUPPORTED_VIDEO_SIZES, supportPreviewSize);
    p.set(CameraParameters::KEY_VIDEO_SIZE, mVideoSize);
    p.set(CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO,mVideoSize);
    p.getSupportedPreviewSizes(mSupportedPreviewSizes);

    int preview_max_width   = 0;
    int preview_max_height  = 0;
    int snapshot_max_width  = 0;
    int snapshot_max_height = 0;
	
    // If these fail, then we are using an invalid cameraId and we'll leave the
    // sizes at zero to catch the error.
    if (mNuCameraV4L2->getPreviewMaxSize(&preview_max_width,
                                         &preview_max_height) < 0)
    {
        LOGE("getPreviewMaxSize fail (%d / %d) \n",
             preview_max_width, preview_max_height);
    }
    if (mNuCameraV4L2->getSnapshotMaxSize(&snapshot_max_width,
                                       &snapshot_max_height) < 0)
    {
        LOGE("getSnapshotMaxSize fail (%d / %d) \n",
             snapshot_max_width, snapshot_max_height);
    }

	LOGV("preview_max_width(%d),preview_max_height(%d),snapshot_max_width(%d),snapshot_max_height(%d)", 
		 preview_max_width,preview_max_height,snapshot_max_width,snapshot_max_height);

    //Set Preview color supported
    String8 previewColorString;

    previewColorString = CameraParameters::PIXEL_FORMAT_YUV420SP;
    //zhuyx@nufront: It must be support more than 2 pixel-formats for cts--begin
    previewColorString.append(",");
    previewColorString.append(CameraParameters::PIXEL_FORMAT_YUV420P);
    //zhuyx@nufront: It must be support more than 2 pixel-formats for cts--end
    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, previewColorString.string());

    //Set preview color to be used
    p.setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);

    //Set recording video color format
    p.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP);

    //set Snapshot size
    p.setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
    p.setPictureSize(snapshot_max_width, snapshot_max_height);
    p.set(CameraParameters::KEY_JPEG_QUALITY, "100");
    p.set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);

    String8 parameterString;

	p.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
	
    //focus mode    
    if (isCameraFaceBack) {
		//back camera
	    parameterString = CameraParameters::FOCUS_MODE_AUTO;
	    parameterString.append(",");
	    parameterString.append(CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO);

	    p.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES,
	          parameterString.string());
	    p.set(CameraParameters::KEY_FOCUS_MODE,
	          CameraParameters::FOCUS_MODE_AUTO);
	    p.set(CameraParameters::KEY_FOCUS_DISTANCES,
	              BACK_CAMERA_AUTO_FOCUS_DISTANCES_STR);
    } else {
    	//front camera
		p.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES,
			  CameraParameters::FOCUS_MODE_FIXED);
		p.set(CameraParameters::KEY_FOCUS_MODE,
			  CameraParameters::FOCUS_MODE_FIXED);
		p.set(CameraParameters::KEY_FOCUS_DISTANCES,
				  FRONT_CAMERA_FOCUS_DISTANCES_STR);
      }

    //thumbnail size
    if (isCameraFaceBack) {
	    p.set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES,
	          "320x240,0x0");
	    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "320");
	    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "240");
	    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "100");
	    //frame rate
	    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, BACK_SUPPORT_FRAME_RATES);
	    p.setPreviewFrameRate(VIDEO_FRONT_FRAME_RATE);
    } else {
	    //thumbnail size
	    p.set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES,
	          "160x120,0x0");
	    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "160");
	    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "120");
	    p.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "100");		
	    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, BACK_SUPPORT_FRAME_RATES);
	    p.setPreviewFrameRate(VIDEO_FRONT_FRAME_RATE);
      }
	
    //flash mode
    if (!isSupportFlashMode) {
			LOGV("Do not support flash mode!");
    	}else {
		    parameterString = CameraParameters::FLASH_MODE_ON;
		    parameterString.append(",");
		    parameterString.append(CameraParameters::FLASH_MODE_OFF);
		    parameterString.append(",");
		    parameterString.append(CameraParameters::FLASH_MODE_AUTO);
#ifdef NU_FLASH_CTRL_IOCTL
		    parameterString.append(",");
		    parameterString.append(CameraParameters::FLASH_MODE_TORCH);
#endif
		    p.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES,
		          parameterString.string());
		    p.set(CameraParameters::KEY_FLASH_MODE,
		          CameraParameters::FLASH_MODE_OFF);
		}
		
    //effect features
    if (!isSupportSpecialEffect) {
		p.set(CameraParameters::KEY_SUPPORTED_EFFECTS, NULL);
		LOGV("Do not support effect features !");
    } else {
	    parameterString = CameraParameters::EFFECT_NONE;
	    parameterString.append(",");
	    parameterString.append(CameraParameters::EFFECT_MONO);
	    parameterString.append(",");
	    parameterString.append(CameraParameters::EFFECT_NEGATIVE);
	 //   parameterString.append(",");
	 //   parameterString.append(CameraParameters::EFFECT_SOLARIZE);
	    parameterString.append(",");
	    parameterString.append(CameraParameters::EFFECT_AQUA);
	    parameterString.append(",");
	    parameterString.append(CameraParameters::EFFECT_SEPIA);
	    p.set(CameraParameters::KEY_SUPPORTED_EFFECTS, parameterString.string());
	    p.set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
     }

    //fps range
	if (isUsbCamera) {
	    p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(15000,30000)");
	    p.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "15000,30000");
    } else {
		p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(10000,30000)");
		p.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "10000,30000");
      }
	
    //focal length
    if (isUsbCamera) {
        p.set(CameraParameters::KEY_FOCAL_LENGTH, USB_FOCAL_LENGTH_STR);
    } else {
	    p.set(CameraParameters::KEY_FOCAL_LENGTH, GC0308_FOCAL_LENGTH_STR);
      }
	
    //ZOOM
    if (!isUsbCamera) {
	    p.set(CameraParameters::KEY_ZOOM_SUPPORTED, "true");
	    p.set(CameraParameters::KEY_MAX_ZOOM, ZOOM_LEVEL_10);//0~10
	    p.set(CameraParameters::KEY_ZOOM, ZOOM_LEVEL_0);//
	    //NOTE:the zoom func was implenmented by ISP at different resolution
	    p.set(CameraParameters::KEY_ZOOM_RATIOS, "100,110,120,130,140,150,160,170,180,190,200");
	  }
	
    //white balance
    if (isSupportDoWhiteBalance) {
        parameterString = CameraParameters::WHITE_BALANCE_AUTO;
        parameterString.append(",");
		parameterString.append(CameraParameters::WHITE_BALANCE_DAYLIGHT);
		parameterString.append(",");
		parameterString.append(CameraParameters::WHITE_BALANCE_CLOUDY_DAYLIGHT);
		parameterString.append(",");
		parameterString.append(CameraParameters::WHITE_BALANCE_INCANDESCENT);
		parameterString.append(",");
		parameterString.append(CameraParameters::WHITE_BALANCE_FLUORESCENT);
		p.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE,
		      parameterString.string());		
		p.set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
	} else if (isSupportAutoWhiteBalance) {
          parameterString = CameraParameters::WHITE_BALANCE_AUTO;
		  parameterString.append(",");
		  parameterString.append(CameraParameters::WHITE_BALANCE_DAYLIGHT);
		  p.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE,
			     parameterString.string());   
		  p.set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
	  }	else { 
		  p.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE,NULL);
		}

    //view field
    if (isUsbCamera) {
	    p.set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, USB_HVIEW_ANGLE);
	    p.set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, USB_VVIEW_ANGLE);
    } else {
	    p.set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, GC0308_HVIEW_ANGLE);
	    p.set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, GC0308_VVIEW_ANGLE);
      }
	       
    p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
    p.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "4");
    p.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "-4");
    p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "1");
	
	memset(&mParameters, sizeof(&mParameters), 0);
    mParameters = p;

    /* make sure mNuCameraV4L2 has all the settings we do.  applications
     * aren't required to call setParameters themselves (only if they
     * want to change something.
     */
    setParameters(p);

    // set frame rate into sensor
    mNuCameraV4L2->setFrameRate(VIDEO_FRONT_FRAME_RATE);
}

void NuCameraHardware::initDefaultParameters(int cameraId,  int size)
{
    LOGD("NuCameraHardware::initDefaultParameters,cameraID: %d", cameraId);
    if (mNuCameraV4L2 == NULL) {
        LOGE("ERR(%s):mNuCameraV4L2 object is NULL", __func__);
        return;
    }
	initCameraParameters(size);// all camera go this fuction to init it's paramer
}

NuCameraHardware::~NuCameraHardware()
{
    LOGD("%s", __func__);
    mNuCameraV4L2->DeinitCamera();
}

//TODO:may be we won't implement this func temporary
//  func:1 register preview buffers
//
status_t NuCameraHardware::setPreviewWindow(preview_stream_ops *w)
{
    int min_bufs;

    mPreviewWindow = w;

    if (!w) {
        LOGV("preview window is NULL!");
        return OK;
    }
    LOGV("NuCameraHardware::setPreviewWindow");

    mPreviewLock.lock();

		CameraHardwareInterface * CamHWIntf =
				   reinterpret_cast<CameraHardwareInterface *>(mCallbackCookie);
		//ANativeWindow *a = anw(w);
		ANativeWindow *a = CamHWIntf->getPreviewWindow();
		if(a!=NULL)
			LOGV("setPreviewWindow: CamHWIntf->ANativeWindow=%p.",a);
		else
			LOGV("setPreviewWindow: CamHWIntf->ANativeWindow == NULL !!!!!");
	
		//setup preview_window width/height
		int current_preview_width, current_preview_height, current_frame_size;
		mNuCameraV4L2->getPreviewSize(&current_preview_width,
									   &current_preview_height,
									   &current_frame_size);
		//if startPreview first time or preview_width changed,then create mLooper,else reuse.
#if 0
		if(mTarget == NULL || current_preview_width != mPreviousPreviewWidth){
			if(mTarget !=NULL && current_preview_width != mPreviousPreviewWidth){
			   mLooper->stop();
			   mTarget->releaseBuffers();
			}
#endif
			sp<MetaData> meta = new MetaData;
			meta->setCString(kKeyMIMEType, "Camera");
			meta->setInt32(kKeyWidth, current_preview_width);
			meta->setInt32(kKeyHeight, current_preview_height);
			meta->setInt32(kKeyColorFormat, OMX_COLOR_FormatYUV420SemiPlanar);
			meta->setInt32(kKeyEnableNativeWindow, 3);
			LOGV("setPreviewWindow: PreviewWindow:W/H=%d/%d,frame_size=%d(0x%x).",current_preview_width,current_preview_height,current_frame_size,current_frame_size);
	
			mTarget = new HardwareRendererCamera(a, meta);
			mLooper = new ALooper;
			mLooper->setName("AwesomeHardwareRenderer Looper");
			mLooper->start(
					false, /* runOnCallingThread */
					true,  /* canCallJava */
					PRIORITY_HIGHEST);
			mLooper->registerHandler(mTarget);
			LOGV("setPreviewWindow:mLooper->registerHandler(mTarget); started!");
	  //  }else
	//		  LOGV("setPreviewWindow:mLooper->registerHandler(mTarget);Both mLooper&mTarget reused.");
		mPreviousPreviewWidth = current_preview_width;
	  
	
    if (mPreviewRunning && !mPreviewStartDeferred) {
        LOGV("stop preview (window change)");
        stopPreviewInternal();
    }

#if 0
    //The minimum define in surfacetexture is 3
    if (w->get_min_undequeued_buffer_count(w, &min_bufs)) {
        LOGE("%s: could not retrieve min undequeued buffer count", __func__);
        return INVALID_OPERATION;
    }

    if (min_bufs >= mBufferCount) {
        LOGE("%s: min undequeued buffer count %d is too high (expecting at most %d)", __func__,
             min_bufs, mBufferCount - 1);
    }

    LOGV("%s: setting buffer count to %d", __func__, mBufferCount);
    if (w->set_buffer_count(w, mBufferCount)) {
        LOGE("%s: could not set buffer count", __func__);
        return INVALID_OPERATION;
    }
#endif

    int preview_width;
    int preview_height;
    mParameters.getPreviewSize(&preview_width, &preview_height);

    const char *str_preview_format = mParameters.getPreviewFormat();

#if 0
    if (w->set_usage(w, GRALLOC_USAGE_SW_WRITE_OFTEN)) {
        LOGE("%s: could not set usage on gralloc buffer", __func__);
        return INVALID_OPERATION;
    }

    if (w->set_buffers_geometry(w,
                                preview_width, preview_height,
                                PREVIEW_WIN_PIXEL_FMT)) {
        LOGE("%s: could not set buffers geometry to %s",
             __func__, str_preview_format);
        return INVALID_OPERATION;
    }
#endif

    if (mPreviewRunning && mPreviewStartDeferred) {
        status_t ret = startPreviewInternal();
        if (ret == OK) {
            mPreviewStartDeferred = false;
            mPreviewCondition.signal();
        }
    }
    mPreviewLock.unlock();

    return OK;
}

void NuCameraHardware::setCallbacks(camera_notify_callback notify_cb,
                                     camera_data_callback data_cb,
                                     camera_data_timestamp_callback data_cb_timestamp,
                                     camera_request_memory get_memory,
                                     void *user)
{
    mNotifyCb = notify_cb;
    mDataCb = data_cb;
    mDataCbTimestamp = data_cb_timestamp;
    mGetMemoryCb = get_memory;
    mCallbackCookie = user;
}

void NuCameraHardware::enableMsgType(int32_t msgType)
{
    LOGV("%s : msgType = 0x%x, mMsgEnabled before = 0x%x",
         __func__, msgType, mMsgEnabled);
    mMsgEnabled |= msgType;

    LOGV("%s : mMsgEnabled = 0x%x", __func__, mMsgEnabled);
}

void NuCameraHardware::disableMsgType(int32_t msgType)
{
    LOGV("%s : msgType = 0x%x, mMsgEnabled before = 0x%x",
         __func__, msgType, mMsgEnabled);
    mMsgEnabled &= ~msgType;
    LOGV("%s : mMsgEnabled = 0x%x", __func__, mMsgEnabled);
}

bool NuCameraHardware::msgTypeEnabled(int32_t msgType)
{
    return (mMsgEnabled & msgType);
}

// ---------------------------------------------------------------------------
void NuCameraHardware::setSkipFrame(int frame)
{
    Mutex::Autolock lock(mSkipFrameLock);
    if (frame < mSkipFrame)
        return;
	LOGV("%s",__func__);
    mSkipFrame = frame;
}

int NuCameraHardware::previewThreadWrapper()
{
    LOGV("%s: starting, mPreviewRunning:%d", __func__ ,mPreviewRunning);
    while (1) {
        mPreviewLock.lock();
        while (!mPreviewRunning) {
            mNuCameraV4L2->stopPreview();
            // signal that we're stopping
            mPreviewStoppedCondition.signal();
            mPreviewCondition.wait(mPreviewLock);
			LOGV("out sleep,go to previewThread, mPreviewRunning = %d",mPreviewRunning);
        }
        mPreviewLock.unlock();

        if (mExitPreviewThread) {
            mNuCameraV4L2->stopPreview();
            return 0;
        }
        previewThread();
    }
}


int NuCameraHardware::previewThread()
{
    //make sure that the preview fps range is less than we defined
   /* if(!isPreviewTime()){
       //LOGI("INFO(%s):Is not preview time,drop it.", __func__);
       return NO_ERROR;
    }*/

    int index = -1;
    nsecs_t timestamp;
    //get one frame data from sensor
    index = mNuCameraV4L2->getPreviewFrame();
    if (index < 0) {
        LOGE("ERR(%s):Fail on NuCameraV4L2->getPreviewFrame()", __func__);
        return UNKNOWN_ERROR;
    }
    //skip frames, some maybe bad
    mSkipFrameLock.lock();
    if (mSkipFrame > 0) {
        //mSkipFrame--;//
        mSkipFrame = mSkipFrame - 3;
        mSkipFrameLock.unlock();
        LOGV("%s: index %d skipping frame", __func__, index);
        return NO_ERROR;
    }
    mSkipFrameLock.unlock();

    int ret = NO_ERROR;
    int width, height, frameSize;
    int record_w, record_h, record_frameSize;

    // get size of frame
    mNuCameraV4L2->getPreviewSize(&width, &height, &frameSize);
	//get address of this frame
	EWLLinearMem_t pmem;
    mNuCameraV4L2->getPreviewFrameAddr(index, &pmem);

#if 0
    //NOTE:we can not implement preview_stream_ops,so the following case will not run
    if (mPreviewWindow && mGrallocHal) {
        buffer_handle_t *bufHandle;
        int stride;
        if (0 != mPreviewWindow->dequeue_buffer(mPreviewWindow, &bufHandle, &stride)) {
            LOGE("Could not dequeue gralloc buffer!\n");
            goto callbacks;
        }
        ret = mPreviewWindow->lock_buffer(mPreviewWindow, bufHandle);
        if (ret != NO_ERROR) {
            LOGE("%s: Unable to lock preview window buffer: %d -> %s",
                   __FUNCTION__, -ret, strerror(-ret));
            mPreviewWindow->cancel_buffer(mPreviewWindow, bufHandle);
            return UNKNOWN_ERROR;
        }


        void *gralloc_mem_addr;
        if (!mGrallocHal->lock(mGrallocHal,
                               *bufHandle,
                               GRALLOC_USAGE_SW_WRITE_OFTEN,
                               0, 0, width, height, &gralloc_mem_addr))
        {
#if NUSMART_CAMERA_RUN_GPU_HARDWARE
            // set frame info
            nusmart_nativewindow_buf  nw_gpu_buf;
            nw_gpu_buf.magic_key = NUSMART_CAMERA_SOURCE_KEY;
            nw_gpu_buf.phy_addr  = pmem.busAddress;
            nw_gpu_buf.vir_addr  = pmem.virtualAddress;
            nw_gpu_buf.size      = frameSize;

            //copy  frame info into gralloced buffer
            memcpy(gralloc_mem_addr, &nw_gpu_buf, sizeof(nw_gpu_buf));
#else		
            memcpy(gralloc_mem_addr, pmem.virtualAddress, frameSize);
#endif
            mGrallocHal->unlock(mGrallocHal, *bufHandle);
        }
        else
        {
            LOGE("%s: could not lock gralloc buffer", __func__);
        }

        if (0 != mPreviewWindow->enqueue_buffer(mPreviewWindow, bufHandle))
        {
            LOGE("Could not enqueue gralloc buffer!\n");
            goto callbacks;
        }
    }
#endif

    if (mPreviewWindow && mGrallocHal) {
        mCameraBuffer = NULL;
        //mVideoBuffer = new MediaBuffer(pmem.virtualAddress, frameSize);
        mCameraBuffer = new MediaBuffer((char*)pmem.busAddress, frameSize);
        mTarget->render(mCameraBuffer,NULL);
    }


callbacks:

    // Notify the client of a new frame.
    if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
        //LOGV("%s: case CAMERA_MSG_PREVIEW_FRAME", __func__);
        // copy frame from ON2
        memcpy(mPreviewHeap->data, pmem.virtualAddress, frameSize);
        NV12ToNV21(mPreviewHeap->data, width, height);  //jpma@nusmart : fix bug #4360
        mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewHeap, 0, NULL, mCallbackCookie);
    }
    mArrived = true;

    Mutex::Autolock lock(mRecordLock);
    if (mRecordRunning == true) {
        timestamp = systemTime(SYSTEM_TIME_MONOTONIC);
        mNuCameraV4L2->getRecordingSize(&record_w, &record_h, &record_frameSize);
        unsigned char * pbuf = (unsigned char *)mRecordHeap->data;
#if NUSMART_CAMERA_RUN_VPU_HARDWARE
        // write address into buffer
        nusmart_nativewindow_buf  vpu_buf;
        vpu_buf.magic_key  = NUSMART_CAMERA_SOURCE_KEY;
        vpu_buf.phy_addr = pmem.busAddress;
        vpu_buf.vir_addr = pmem.virtualAddress;
        vpu_buf.size     = record_frameSize;
        memcpy(pbuf, &vpu_buf, sizeof (vpu_buf));
#else
        // write image into buffer
        memcpy(pbuf, pmem.virtualAddress, record_frameSize);
#endif
        // Notify the client of a new frame.
        if (mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
			// LOGV("CAMERA_MSG_VIDEO_FRAME, timestamp = %lld", timestamp);
             mDataCbTimestamp(timestamp, CAMERA_MSG_VIDEO_FRAME, mRecordHeap, 0, mCallbackCookie);
        }
    }
    return ret;
}

status_t NuCameraHardware::startPreview()
{
    int ret = 0;
	//nsecs_t end,remaining;
    LOGD("%s :", __func__);

    if (waitCaptureCompletion() != NO_ERROR) {
        return TIMED_OUT;
    }

    mPreviewLock.lock();

    if (mPreviewRunning) {
        // already running
        LOGV("%s : preview thread already running", __func__);
        mPreviewLock.unlock();
        return INVALID_OPERATION;
    }

    mPreviewRunning = true;
    mPreviewStartDeferred = false;

    mPreviewAfter = 0;
    mLastPreviewed = 0;
    int frameRate = mParameters.getPreviewFrameRate();

    if (mNuCameraV4L2->getCameraId() == NuCameraV4L2::CAMERA_ID_BACK){
         mPreviewAfter = 1000000 / VIDEO_BACK_FRAME_RATE;
    } else {
         mPreviewAfter = 1000000 / VIDEO_FRONT_FRAME_RATE;
    }

    if (!mPreviewWindow) {
        LOGD("%s : deferring", __func__);
        mPreviewStartDeferred = true;
        mPreviewLock.unlock();
        return NO_ERROR;
    }

    LOGD("%s : call startPreviewInternal()", __func__);
    ret = startPreviewInternal();
    if (ret == OK)
        mPreviewCondition.signal();

    mPreviewLock.unlock();

////add by jzchen wait 0.2s to appear preview windows when continuous taking picture

   /* end = 200000000LL + systemTime(SYSTEM_TIME_MONOTONIC);
    while (1) {
        remaining = end - systemTime(SYSTEM_TIME_MONOTONIC);
        if (remaining <= 0) {
            LOGE(" Timed out waiting preview .");
			break;
        }
        LOGV(" Waiting for preview to complete.");
       
      }*/
  	
    return ret;
}

status_t NuCameraHardware::startPreviewInternal()
{
    if (!mPreviewHeap) {
        int w, h, size;
        mNuCameraV4L2->getPreviewSize(&w, &h, &size);
        mPreviewHeap = mGetMemoryCb(-1, size, 1, 0);
        if (!mPreviewHeap) {
            LOGE("ERR(%s): Preview heap creation fail", __func__);
            return UNKNOWN_ERROR;
        }
    }

    int ret  = mNuCameraV4L2->startPreview();
    if (ret < 0) {
        LOGE("ERR(%s):Fail on mNuCameraV4L2->startPreview()", __func__);
        return UNKNOWN_ERROR;
    }

    setSkipFrame(INITIAL_SKIP_FRAME);

    return NO_ERROR;
}

void NuCameraHardware::stopPreviewInternal()
{
    /* request that the preview thread stop. */
    if (mPreviewRunning)
    {
        mPreviewRunning = false;
        if (!mPreviewStartDeferred)
        {
            mPreviewCondition.signal();
            /* wait until preview thread is stopped */
            mPreviewStoppedCondition.wait(mPreviewLock);
        }
        else
        {
            LOGE("%s : preview running but deferred, doing nothing", __func__);
        }
    }
    else
    {
        LOGI("%s : preview not running, doing nothing", __func__);
    }
}

void NuCameraHardware::stopPreview()
{
    /* request that the preview thread stop. */
    mPreviewLock.lock();
    stopPreviewInternal();
    mPreviewLock.unlock();
    if (mPreviewHeap)
    {
         mPreviewHeap->release(mPreviewHeap);
         mPreviewHeap = NULL;
    }
}

bool NuCameraHardware::previewEnabled()
{
    Mutex::Autolock lock(mPreviewLock);
    return mPreviewRunning;
}

// ---------------------------------------------------------------------------

status_t NuCameraHardware::startRecording()
{
    LOGV("%s :", __func__);
    Mutex::Autolock lock(mRecordLock);
#if NUSMART_CAMERA_RUN_VPU_HARDWARE
    mRecordHeap = mGetMemoryCb(-1, sizeof(nusmart_nativewindow_buf), 1, NULL);
#else
    int w, h, size;
    mNuCameraV4L2->getRecordingSize(&w, &h, &size);
    mRecordHeap = mGetMemoryCb(-1, size, 1, NULL);
#endif

    if (!mRecordHeap) {
        LOGE("ERR(%s): Record heap creation fail", __func__);
        return UNKNOWN_ERROR;
    }

    if (!mRecordRunning) {
        mRecordRunning = true;
    }
   // int focusMode = mNuCameraV4L2->getFocusMode();
   // if (FOCUS_MODE_CONT_VIDEO == focusMode){
   //    mNuCameraV4L2->setAutofocus();
   // }
    return NO_ERROR;
}

void NuCameraHardware::stopRecording()
{
    Mutex::Autolock lock(mRecordLock);

    if (mRecordRunning == true) {
        mRecordRunning = false;
    }

  /* 
  	int focusMode = mNuCameraV4L2->getFocusMode();
    if (FOCUS_MODE_CONT_VIDEO == focusMode){
        mNuCameraV4L2->cancelAutofocus();
    }
   */
    if (mRecordHeap)
    {
         mRecordHeap->release(mRecordHeap);
         mRecordHeap = NULL;
    }

    mRecordRunning = false;
}

bool NuCameraHardware::recordingEnabled()
{
    LOGV("%s :", __func__);

    return mRecordRunning;
}

void NuCameraHardware::releaseRecordingFrame(const void *opaque)
{
    /*
    struct addrs *addrs = (struct addrs *)opaque;
    mNuCameraV4L2->releaseRecordFrame(addrs->buf_index);
    */
}

int NuCameraHardware::autoFocusThread()
{
    int count =0;
    int af_status =0 ;

    LOGV("%s : starting", __func__);

    /* block until we're told to start.  we don't want to use
     * a restartable thread and requestExitAndWait() in cancelAutoFocus()
     * because it would cause deadlock between our callbacks and the
     * caller of cancelAutoFocus() which both want to grab the same lock
     * in CameraServices layer.
     */
    mFocusLock.lock();
    /* check early exit request */
    if (mExitAutoFocusThread) {
        mFocusLock.unlock();
        LOGV("%s : exiting on request0", __func__);
        return NO_ERROR;
    }
    mFocusCondition.wait(mFocusLock);
    /* check early exit request */
    if (mExitAutoFocusThread) {
        mFocusLock.unlock();
        LOGV("%s : exiting on request1", __func__);
        return NO_ERROR;
    }
    mFocusLock.unlock();
	
	mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
	return NO_ERROR;
	
	/*
    LOGV("%s : calling setAutoFocus", __func__);
    if (mNuCameraV4L2->setAutofocus() < 0) {
        LOGE("ERR(%s):Fail on mNuCameraV4L2->setAutofocus()", __func__);
        return UNKNOWN_ERROR;
    }

    af_status = mNuCameraV4L2->getAutoFocusResult();
    if (af_status == AF_SUCCESS) {
        LOGV("%s : AF Success!!", __func__);
        if (mMsgEnabled & CAMERA_MSG_FOCUS)
            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
    } else {
        LOGV("%s : AF Fail !!", __func__);
        LOGV("%s : mMsgEnabled = 0x%x", __func__, mMsgEnabled);
        if (mMsgEnabled & CAMERA_MSG_FOCUS)
            mNotifyCb(CAMERA_MSG_FOCUS, false, 0, mCallbackCookie);
    }
    LOGV("%s : exiting with no error", __func__);
    return NO_ERROR;
    */
    
}

status_t NuCameraHardware::autoFocus()
{
    /*signal autoFocusThread to run once*/
    mFocusCondition.signal();
    return NO_ERROR;
    
}

status_t NuCameraHardware::cancelAutoFocus()
{
    // cancelAutoFocus should be allowed after preview is started. But if
    // the preview is deferred, cancelAutoFocus will fail. Ignore it if that is
    // the case.
   /* if (mNuCameraV4L2->getCameraId() == NuCameraV4L2::CAMERA_ID_FRONT){
        return NO_ERROR;
    }
    if (mPreviewRunning && mPreviewStartDeferred) return NO_ERROR;

    if (mNuCameraV4L2->cancelAutofocus() < 0) {
        LOGE("ERR(%s):Fail on mNuCameraV4L2->cancelAutofocus()", __func__);
        return UNKNOWN_ERROR;
    }
    */
    return NO_ERROR;
}

int NuCameraHardware::pictureThreadInternal()
{
    int ret = NO_ERROR;
    int index = -1;
    int skip_pics = SNAP_SKIP_FRAME;
    // jpeg encoder init
    ret = mNuCameraV4L2->jpegInit();
    if (ret < 0) {
        LOGE("ERR(%s):Fail on NuCameraV4L2->jpegInit()", __func__);
        ret = UNKNOWN_ERROR;
        goto out;
    }//jzyang error

    // start snapshot
    if( mNuCameraV4L2->setSnapshotCmd() < 0 ){
        LOGE("%s: mNuCameraV4L2->setSnapshotCmd() Failed!", __func__);
        ret = UNKNOWN_ERROR;
        goto out;
    }

    // flash
#if 0
    	if (mNuCameraV4L2->getCameraId() == NuCameraV4L2::CAMERA_ID_BACK){
        //Do flashing
        if ( mNuCameraV4L2->flashing(1) < 0){
            LOGE("ERR(%s), mNuCameraV4L2->flashing(1) Failed!", __func__);
            ret = UNKNOWN_ERROR;
            goto out;
        }
    }
#endif

    //get snapshot frame
    while(skip_pics >= 0){
        index = mNuCameraV4L2->getSnapshotFrame();
        if (index < 0) {
            LOGE("ERR(%s):Fail on NuCameraV4L2->getSnapshotFrame()", __func__);
            ret = UNKNOWN_ERROR;
            goto out;
        }
        skip_pics--;
    }
   /*
   	  if (mNuCameraV4L2->getCameraId() == NuCameraV4L2::CAMERA_ID_BACK){
        //Close flashing
        if ( mNuCameraV4L2->flashing(0) < 0){
            LOGE("ERR(%s), mNuCameraV4L2->flashing(0) Failed!",__func__);
            ret = UNKNOWN_ERROR;
            goto out;
        }
    }
    */

    // call shutter callback
    if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
         mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
    }

    //get address of this frame
    EWLLinearMem_t pmem;
    mNuCameraV4L2->getCaptureFrameAddr(index, &pmem);

    // raw image callback
    if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE) {
        LOGV("%s: case CAMERA_MSG_RAW_IMAGE, memcpy data to RawHeap", __func__);
        int picWidth, picHeight, picSize;
        mNuCameraV4L2->getSnapshotSize(&picWidth, &picHeight, &picSize);
        memcpy(mRawHeap->data, pmem.virtualAddress, picSize);
        mDataCb(CAMERA_MSG_RAW_IMAGE, mRawHeap, 0, NULL, mCallbackCookie);
    } else if (mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY) {
        LOGV("%s: case CAMERA_MSG_RAW_IMAGE_NOTIFY, notify to client.", __func__);
        mNotifyCb(CAMERA_MSG_RAW_IMAGE_NOTIFY, 0, 0, mCallbackCookie);
    }

    // jpeg callback
    if (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE) {
         // jpeg encoding
         int jpegSize;
         ret = mNuCameraV4L2->jpegEncoding(index, &jpegSize);
         if (ret == NO_ERROR)
         {
             //alloc mem for EXIF info
             camera_memory_t *exifHeap = mGetMemoryCb(-1, EXIF_BUF_SIZE, 1, 0);
             if (NULL == exifHeap){
                  LOGE("ERR(%s): Malloc exifHeap failed!", __func__);
                  ret = UNKNOWN_ERROR;
                  goto out;
             }
             //make up exif info
             int exifSize = mNuCameraV4L2->getExif((unsigned char *)exifHeap->data);
             if (exifSize < 0)
             {
                  ret = UNKNOWN_ERROR;
                  LOGE("ERR(%s): getExif Failed !", __func__);
                  exifHeap->release(exifHeap);
                  goto out;
             }

             camera_memory_t *pmem = mGetMemoryCb(-1, jpegSize + exifSize , 1, 0);
             if (NULL == pmem){
                   ret = ENOMEM;
                   exifHeap->release(exifHeap);
                   goto out;
             }

             // copy jpeg frame
             uint8_t *ptr = (uint8_t *) pmem->data;
             mNuCameraV4L2->jpegGetImage(ptr+exifSize);
             // add jpeg START Marker and EXIF info
             memset(ptr, 0xFF, 1);
             memset(ptr+1, 0xD8,1);
             memcpy(ptr+2, exifHeap->data, exifSize);
             //run jpeg callback
             mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, pmem, 0, NULL, mCallbackCookie);
             //release memory
             pmem->release(pmem);
             exifHeap->release(exifHeap);
         }
    }

    LOGV("%s : pictureThread end", __func__);

out:
    mRawHeap->release(mRawHeap);
    mRawHeap = NULL;
    mNuCameraV4L2->endSnapshot();
    mCaptureLock.lock();
    mCaptureInProgress = false;
    mCaptureCondition.broadcast();
    mCaptureLock.unlock();

    return ret;
}

int NuCameraHardware::recordingThreadInternal()
{
    Mutex::Autolock lock(mRecordLock);
    if (mRecordRunning == true && mArrived == true) {
        mArrived = false;
        int index;
        int width, height, frameSize;
        nsecs_t timestamp;
        timestamp = systemTime(SYSTEM_TIME_MONOTONIC);

        mNuCameraV4L2->getRecordingSize(&width, &height, &frameSize);

        //get record frame
        index= mNuCameraV4L2->getRecordFrame();
        if (index < 0) {
             LOGE("ERR(%s):Fail on NuCameraV4L2->getRecord()", __func__);
             return UNKNOWN_ERROR;
        }
        //get address of this frame
        EWLLinearMem_t pmem;
        mNuCameraV4L2->getPreviewFrameAddr(index, &pmem);
        unsigned char * pbuf = (unsigned char *)mRecordHeap->data;

#if NUSMART_CAMERA_RUN_VPU_HARDWARE
        // write address into buffer
        nusmart_nativewindow_buf  vpu_buf;
        vpu_buf.magic_key  = NUSMART_CAMERA_SOURCE_KEY;
        vpu_buf.phy_addr = pmem.busAddress;
        vpu_buf.vir_addr = pmem.virtualAddress;
        vpu_buf.size     = frameSize;
        memcpy(pbuf, &vpu_buf, sizeof (vpu_buf));
#else
        // write image into buffer
        memcpy(pbuf, pmem.virtualAddress, frameSize);
#endif

        // Notify the client of a new frame.
        if (mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
             mDataCbTimestamp(timestamp, CAMERA_MSG_VIDEO_FRAME, mRecordHeap, 0, mCallbackCookie);
        }

    }
    return NO_ERROR;
}

inline bool NuCameraHardware::captureThread()
{
    pictureThreadInternal();
    return true;
}

status_t NuCameraHardware::waitCaptureCompletion() {
    // 5 seconds timeout
    nsecs_t endTime = 5000000000LL + systemTime(SYSTEM_TIME_MONOTONIC);
    Mutex::Autolock lock(mCaptureLock);
    while (mCaptureInProgress) {
        nsecs_t remainingTime = endTime - systemTime(SYSTEM_TIME_MONOTONIC);
        if (remainingTime <= 0) {
            LOGE("Timed out waiting picture thread.");
            return TIMED_OUT;
        }
        LOGV("Waiting for picture thread to complete.");
        mCaptureCondition.waitRelative(mCaptureLock, remainingTime);
    }
    return NO_ERROR;
}

status_t NuCameraHardware::takePicture()
{
   /* if (mPreviewRunning){
        if (mNuCameraV4L2->getCameraId() == NuCameraV4L2::CAMERA_ID_BACK){
            //tell sensor to takepic
            LOGV("%s, Call NuCameraV4L2->setTakepicureFlag(0)",__func__);
            if (mNuCameraV4L2->setTakepicureFlag(TAKE_PICUTRE_FLAG) < 0) {
                LOGE("ERR(%s):Fail on mNuCameraV4L2->setTakepicureFlag(0)", __func__);
            }
            // set current AEC value
            mNuCameraV4L2->setAECValue();
        }
    }*/
    stopPreview();

    if (waitCaptureCompletion() != NO_ERROR) {
        return TIMED_OUT;
    }
    if (!mRawHeap) {
        int picWidth, picHeight, picSize;
        mNuCameraV4L2->getSnapshotSize(&picWidth, &picHeight, &picSize);
        mRawHeap = mGetMemoryCb(-1, picSize, 1, 0);
        if (!mRawHeap) {
            LOGE("ERR(%s): Raw heap creation fail", __func__);
        }
    }

    if (mCaptureThread->startThread(true) != NO_ERROR) {
        LOGE("%s : couldn't run picture thread", __func__);
        return INVALID_OPERATION;
    }
    mCaptureLock.lock();
    mCaptureInProgress = true;
    mCaptureLock.unlock();

    return NO_ERROR;
}

status_t NuCameraHardware::cancelPicture()
{

    if (mCaptureThread.get()) {
        mCaptureThread->requestExitAndWait();
    }

    return NO_ERROR;
}

status_t NuCameraHardware::dump(int fd) const
{
    const size_t SIZE = 256;
    char buffer[SIZE];
    String8 result;
    const Vector<String16> args;

    if (mNuCameraV4L2 != 0) {
        mNuCameraV4L2->dump(fd);
        mParameters.dump(fd, args);
        mInternalParameters.dump(fd, args);
        snprintf(buffer, 255, " preview running(%s)\n", mPreviewRunning?"true": "false");
        result.append(buffer);
    } else {
        result.append("No camera client yet.\n");
    }
    write(fd, result.string(), result.size());
    return NO_ERROR;
}

bool NuCameraHardware::isSupportedPreviewSize(const int width,
                                               const int height) const
{
    LOGV("%s", __func__);
    unsigned int i;
    for (i = 0; i < mSupportedPreviewSizes.size(); i++) {
        if (mSupportedPreviewSizes[i].width == width &&
                mSupportedPreviewSizes[i].height == height) {
              LOGV("SupportedPreviewSize:%d x %d",width, height);
              return true;
		}
    }

    return false;
}

bool NuCameraHardware::isSupportedParameter(const char * const parm,
        const char * const supported_parm) const
{
    const char *pStart;
    const char *pEnd;

    if (!parm || !supported_parm)
        return false;

    pStart = supported_parm;

    while (true) {
        pEnd = strchr(pStart, ',');
        if (!pEnd) {
            if (!strcmp(parm, pStart))
                return true;
            else
                return false;
        }
        if (!strncmp(parm, pStart, pEnd - pStart)) {
            return true;
        }
        pStart = pEnd + 1;
    }
    /* NOTREACHED */
}

status_t NuCameraHardware::setParameters(const CameraParameters& params)
{

    status_t ret = NO_ERROR;

    /* if someone calls us while picture thread is running, it could screw
     * up the sensor quite a bit so return error.
     */
    //NOTE:waitCaptureCompletion is necessary ?
    if (waitCaptureCompletion() != NO_ERROR) {
        return TIMED_OUT;
    }

    // preview size
    int new_preview_width  = 0;
    int new_preview_height = 0;
    params.getPreviewSize(&new_preview_width, &new_preview_height);
    const char *new_str_preview_format = params.getPreviewFormat();
    LOGV("%s : new_preview_width x new_preview_height = %dx%d, format = %s",
         __func__, new_preview_width, new_preview_height, new_str_preview_format);

    if (strcmp(new_str_preview_format, CameraParameters::PIXEL_FORMAT_YUV420SP)
        && strcmp(new_str_preview_format, CameraParameters::PIXEL_FORMAT_YUV420P))
    {
        LOGE("Unsupported preview color format: %s", new_str_preview_format);
        return BAD_VALUE;
    }

    if (0 < new_preview_width && 0 < new_preview_height &&
            new_str_preview_format != NULL &&
            isSupportedPreviewSize(new_preview_width, new_preview_height)) {
        int new_preview_format = V4L2_PIX_FMT_YUV420;

        int current_preview_width, current_preview_height, current_frame_size;
        mNuCameraV4L2->getPreviewSize(&current_preview_width,
                                   &current_preview_height,
                                   &current_frame_size);
        int current_pixel_format = mNuCameraV4L2->getPreviewPixelFormat();

        if (current_preview_width != new_preview_width ||
                    current_preview_height != new_preview_height ||
                    current_pixel_format != new_preview_format) {
            if (mNuCameraV4L2->setPreviewSize(new_preview_width, new_preview_height,
                                           new_preview_format) < 0) {
                LOGE("ERR(%s):Fail on mNuCameraV4L2->setPreviewSize(width(%d), height(%d), format(%d))",
                     __func__, new_preview_width, new_preview_height, PREVIEW_WIN_PIXEL_FMT);
                ret = UNKNOWN_ERROR;
            } else {
                if (mPreviewWindow) {
                    if (mPreviewRunning && !mPreviewStartDeferred) {
                        LOGE("ERR(%s): preview is running, cannot change size and format!",
                             __func__);
                        ret = INVALID_OPERATION;
                    }

                    LOGV("%s: mPreviewWindow (%p) set_buffers_geometry", __func__, mPreviewWindow);
                    LOGV("%s: mPreviewWindow->set_buffers_geometry (%p)", __func__,
                         mPreviewWindow->set_buffers_geometry);
                    mPreviewWindow->set_buffers_geometry(mPreviewWindow,
                                                         new_preview_width, new_preview_height,
                                                         PREVIEW_WIN_PIXEL_FMT);
                    LOGV("%s: DONE mPreviewWindow (%p) set_buffers_geometry", __func__, mPreviewWindow);
                }

                mParameters.setPreviewSize(new_preview_width, new_preview_height);
                mParameters.setPreviewFormat(new_str_preview_format);
            }
        }
        else LOGV("%s: preview size and format has not changed", __func__);
    } else {
        LOGE("%s: Invalid preview size(%dx%d)",
                __func__, new_preview_width, new_preview_height);

        ret = INVALID_OPERATION;
    }

    int new_picture_width  = 0;
    int new_picture_height = 0;

    params.getPictureSize(&new_picture_width, &new_picture_height);
    LOGV("%s : new_picture_width x new_picture_height = %dx%d", __func__, new_picture_width, new_picture_height);
    if (0 < new_picture_width && 0 < new_picture_height && 
			isSupportedPreviewSize(new_picture_width,new_picture_height)) {
        if (mNuCameraV4L2->setSnapshotSize(new_picture_width, new_picture_height) < 0) {
            LOGE("ERR(%s):Fail on mNuCameraV4L2->setSnapshotSize(width(%d), height(%d))",
                    __func__, new_picture_width, new_picture_height);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.setPictureSize(new_picture_width, new_picture_height);
        }
    } else {
        LOGE("%s: Invalid picture size(%dx%d)",
                __func__, new_picture_width, new_picture_height);

        ret = INVALID_OPERATION;
    }

    // picture format
    const char *new_str_picture_format = params.getPictureFormat();
    LOGV("%s : new_str_picture_format %s", __func__, new_str_picture_format);
    if (new_str_picture_format != NULL) {
        int new_picture_format = 0;

        if (!strcmp(new_str_picture_format, CameraParameters::PIXEL_FORMAT_JPEG))
            new_picture_format = V4L2_PIX_FMT_NV12;
        else if (!strcmp(new_str_picture_format, "yuv422i"))
            new_picture_format = V4L2_PIX_FMT_YUYV;
        else if (!strcmp(new_str_picture_format, CameraParameters::PIXEL_FORMAT_RGB565))
            new_picture_format = V4L2_PIX_FMT_RGB565;
        else
            new_picture_format = V4L2_PIX_FMT_NV12; //for 3rd party

        if (mNuCameraV4L2->setSnapshotPixelFormat(new_picture_format) < 0) {
            LOGE("ERR(%s):Fail on mNuCameraV4L2->setSnapshotPixelFormat(format(%d))", __func__, new_picture_format);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.setPictureFormat(new_str_picture_format);
        }
    }
LOGV("JZYANG ret1 = %d", ret);
    //JPEG image quality
    int new_jpeg_quality = params.getInt(CameraParameters::KEY_JPEG_QUALITY);
    if (new_jpeg_quality >=1 && new_jpeg_quality <= 100) {
        if (mNuCameraV4L2->setJpegQuality(new_jpeg_quality) < 0) {
            LOGE("ERR(%s):Fail on mNuCameraV4L2->setJpegQuality(quality(%d))", __func__, new_jpeg_quality);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_JPEG_QUALITY, new_jpeg_quality);
        }
    }
LOGV("JZYANG ret2 = %d", ret);

    // JPEG thumbnail size
    int new_jpeg_thumbnail_width = params.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
    int new_jpeg_thumbnail_height= params.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
    if (0 <= new_jpeg_thumbnail_width && 0 <= new_jpeg_thumbnail_height) {
        if (mNuCameraV4L2->setJpegThumbnailSize(new_jpeg_thumbnail_width, new_jpeg_thumbnail_height) < 0) {
            LOGE("ERR(%s):Fail on mNuCameraV4L2->setJpegThumbnailSize(width(%d), height(%d))", __func__, new_jpeg_thumbnail_width, new_jpeg_thumbnail_height);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, new_jpeg_thumbnail_width);
            mParameters.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, new_jpeg_thumbnail_height);
        }
    }
LOGV("JZYANG ret3 = %d", ret);

    // frame rate
    /* ignore any fps request, we're determine fps automatically based
     * on scene mode.  don't return an error because it causes CTS failure.
     */
    int new_frame_rate = params.getPreviewFrameRate();
    if (new_frame_rate != mParameters.getPreviewFrameRate()) {
        LOGW("WARN(%s): request for preview frame %d not allowed, != %d\n",
             __func__, new_frame_rate, mParameters.getPreviewFrameRate());
        mParameters.setPreviewFrameRate(new_frame_rate);
    }

    //zoom
	    int old_zoom_value,new_zoom_value;
	    old_zoom_value = mParameters.getInt(CameraParameters::KEY_ZOOM);
	    new_zoom_value = params.getInt(CameraParameters::KEY_ZOOM);
	    if( new_zoom_value < 0 ){
	        new_zoom_value = ZOOM_LEVEL_0;
	    }
	    LOGV("%s, mNuCameraV4L2->setZoom(resolution:%dx%d, zoom_value:%d).", __func__,
	                    new_preview_width, new_preview_height, new_zoom_value);

	    if (old_zoom_value != new_zoom_value){
	        if (mNuCameraV4L2->setZoom(new_preview_width, new_preview_height, new_zoom_value) < 0){
	            LOGE("%s, mNuCameraV4L2->setZoom(resolution:%dx%d, zoom_value:%d)", __func__,
	                     new_preview_width, new_preview_height, new_zoom_value);
	            ret = UNKNOWN_ERROR;
	        } else {
	            mParameters.set(CameraParameters::KEY_ZOOM,new_zoom_value);
	        }
	    }
		
LOGV("JZYANG ret4 = %d", ret);

    // rotation
    int new_rotation = params.getInt(CameraParameters::KEY_ROTATION);
    LOGV("%s : new_rotation %d", __func__, new_rotation);
    if (0 <= new_rotation) {
        LOGV("%s : set orientation:%d\n", __func__, new_rotation);
        if (mNuCameraV4L2->setExifOrientationInfo(new_rotation) < 0) {
            LOGE("ERR(%s):Fail on mNuCameraV4L2->setExifOrientationInfo(%d)", __func__, new_rotation);
            ret = UNKNOWN_ERROR;
        } else {
            mParameters.set(CameraParameters::KEY_ROTATION, new_rotation);
        }
    }
LOGV("JZYANG ret5 = %d", ret);

    // brightness
	    int new_exposure_compensation = params.getInt(CameraParameters::KEY_EXPOSURE_COMPENSATION);
	    int max_exposure_compensation = params.getInt(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION);
	    int min_exposure_compensation = params.getInt(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION);
	    LOGV("%s : new_exposure_compensation %d", __func__, new_exposure_compensation);
	    if ((min_exposure_compensation <= new_exposure_compensation) &&
	        (max_exposure_compensation >= new_exposure_compensation)) {
	        if (mNuCameraV4L2->setBrightness(new_exposure_compensation) < 0) {
	            LOGE("ERR(%s):Fail on mNuCameraV4L2->setBrightness(brightness(%d))", __func__, new_exposure_compensation);
	            ret = UNKNOWN_ERROR;
	        } else {
	            mParameters.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, new_exposure_compensation);
	        }
	    }
		
LOGV("JZYANG ret6 = %d", ret);

    // whitebalance
	    const char *new_white_str = params.get(CameraParameters::KEY_WHITE_BALANCE);
	    LOGV("%s : new_white_str %s", __func__, new_white_str);
	    if (new_white_str != NULL) {
	        int new_white = -1;

	        if (!strcmp(new_white_str, CameraParameters::WHITE_BALANCE_AUTO))
	            new_white = WHITE_BALANCE_AUTO;
	        else if (!strcmp(new_white_str,
	                         CameraParameters::WHITE_BALANCE_DAYLIGHT))
	            new_white = WHITE_BALANCE_SUNNY;
	        else if (!strcmp(new_white_str,
	                         CameraParameters::WHITE_BALANCE_CLOUDY_DAYLIGHT))
	            new_white = WHITE_BALANCE_CLOUDY;
	        else if (!strcmp(new_white_str,
	                         CameraParameters::WHITE_BALANCE_INCANDESCENT))
	            new_white = WHITE_BALANCE_HOME;
	        else if (!strcmp(new_white_str,
	                         CameraParameters::WHITE_BALANCE_FLUORESCENT))
	            new_white = WHITE_BALANCE_OFFICE;
	        else {
	            LOGE("ERR(%s):Invalid white balance(%s)", __func__, new_white_str); //twilight, shade, warm_flourescent
	            ret = UNKNOWN_ERROR;
	        }

	        if (0 <= new_white) {
	            if (mNuCameraV4L2->setWhiteBalance(new_white) < 0) {
	                LOGE("ERR(%s):Fail on mNuCameraV4L2->setWhiteBalance(white(%d))", __func__, new_white);
	                ret = UNKNOWN_ERROR;
	            } else {
	                mParameters.set(CameraParameters::KEY_WHITE_BALANCE, new_white_str);
	            }
	        }
	    }
		
LOGV("JZYANG ret7 = %d", ret);

    // scene mode
    const char *new_scene_mode_str = params.get(CameraParameters::KEY_SCENE_MODE);
    const char *current_scene_mode_str = mParameters.get(CameraParameters::KEY_SCENE_MODE);

    // fps range
    int new_min_fps = 0;
    int new_max_fps = 0;
    int current_min_fps, current_max_fps;
    params.getPreviewFpsRange(&new_min_fps, &new_max_fps);
    mParameters.getPreviewFpsRange(&current_min_fps, &current_max_fps);
    /* our fps range is determined by the sensor, reject any request
     * that isn't exactly what we're already at.
     * but the check is performed when requesting only changing fps range
     */
    if (new_scene_mode_str && current_scene_mode_str) {
        if (!strcmp(new_scene_mode_str, current_scene_mode_str)) {
            if ((new_min_fps != current_min_fps) || (new_max_fps != current_max_fps)) {
                LOGW("%s : requested new_min_fps = %d, new_max_fps = %d not allowed",
                        __func__, new_min_fps, new_max_fps);
                LOGE("%s : current_min_fps = %d, current_max_fps = %d",
                        __func__, current_min_fps, current_max_fps);
                ret = UNKNOWN_ERROR;
            }
        }
    } else {
        /* Check basic validation if scene mode is different */
        if ((new_min_fps > new_max_fps) ||
            (new_min_fps < 0) || (new_max_fps < 0))
      ret = UNKNOWN_ERROR;
    }
	
LOGV("JZYANG ret8 = %d", ret);//start here

    const char *new_focus_mode_str = params.get(CameraParameters::KEY_FOCUS_MODE);

    if (mNuCameraV4L2->getCameraId() == NuCameraV4L2::CAMERA_ID_BACK) {
        int  new_scene_mode = -1;

        const char *new_flash_mode_str = params.get(CameraParameters::KEY_FLASH_MODE);

        // fps range is (15000,30000) by default.
        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(15000,30000)");
        mParameters.set(CameraParameters::KEY_PREVIEW_FPS_RANGE,
                "15000,30000");
        if (new_scene_mode_str && current_scene_mode_str) {
        if (!strcmp(new_scene_mode_str, CameraParameters::SCENE_MODE_AUTO)) {
            new_scene_mode = SCENE_MODE_NONE;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "on,off,auto");
        } else {
            // defaults for non-auto scene modes
                new_focus_mode_str = CameraParameters::FOCUS_MODE_AUTO;
            new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;

            if (!strcmp(new_scene_mode_str,
                       CameraParameters::SCENE_MODE_PORTRAIT)) {
                new_scene_mode = SCENE_MODE_PORTRAIT;
                new_flash_mode_str = CameraParameters::FLASH_MODE_AUTO;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "auto");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_LANDSCAPE)) {
                new_scene_mode = SCENE_MODE_LANDSCAPE;
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_SPORTS)) {
                new_scene_mode = SCENE_MODE_SPORTS;
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_PARTY)) {
                new_scene_mode = SCENE_MODE_PARTY_INDOOR;
                new_flash_mode_str = CameraParameters::FLASH_MODE_AUTO;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "auto");
            } else if ((!strcmp(new_scene_mode_str,
                                CameraParameters::SCENE_MODE_BEACH)) ||
                        (!strcmp(new_scene_mode_str,
                                 CameraParameters::SCENE_MODE_SNOW))) {
                new_scene_mode = SCENE_MODE_BEACH_SNOW;
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_SUNSET)) {
                new_scene_mode = SCENE_MODE_SUNSET;
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_NIGHT)) {
                new_scene_mode = SCENE_MODE_NIGHTSHOT;
                mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(4000,30000)");
                mParameters.set(CameraParameters::KEY_PREVIEW_FPS_RANGE,
                                "4000,30000");
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_FIREWORKS)) {
                new_scene_mode = SCENE_MODE_FIREWORKS;
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else if (!strcmp(new_scene_mode_str,
                               CameraParameters::SCENE_MODE_CANDLELIGHT)) {
                new_scene_mode = SCENE_MODE_CANDLE_LIGHT;
                new_flash_mode_str = CameraParameters::FLASH_MODE_OFF;
                mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, "off");
            } else {
                LOGE("%s::unmatched scene_mode(%s)",
                        __func__, new_scene_mode_str); //action, night-portrait, theatre, steadyphoto
                ret = UNKNOWN_ERROR;
            }
          }
        }//end non-auto
LOGV("JZYANG ret9 = %d", ret);

        // focus mode
        if (new_focus_mode_str != NULL) {
            int  new_focus_mode = -1;

            if (!strcmp(new_focus_mode_str,
                        CameraParameters::FOCUS_MODE_AUTO)) {
                new_focus_mode = FOCUS_MODE_AUTO;
                mParameters.set(CameraParameters::KEY_FOCUS_DISTANCES,
                                BACK_CAMERA_AUTO_FOCUS_DISTANCES_STR);
            } else if (!strcmp(new_focus_mode_str,
                        CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO)) {
                new_focus_mode = FOCUS_MODE_CONT_VIDEO;
            } else {
                LOGE("%s::unmatched focus_mode(%s)", __func__, new_focus_mode_str);
                ret = UNKNOWN_ERROR;
            }
LOGV("JZYANG ret10 = %d", ret);

            if (0 <= new_focus_mode) {
                if (mNuCameraV4L2->setFocusMode(new_focus_mode) < 0) {
                    LOGE("%s::mNuCameraV4L2->setFocusMode(%d) fail", __func__, new_focus_mode);
                    ret = UNKNOWN_ERROR;
                } else {
                    mParameters.set(CameraParameters::KEY_FOCUS_MODE, new_focus_mode_str);
                }
            }
        }
        //end focus mode
LOGV("JZYANG ret11 = %d", ret);

        // flash..
        if (new_flash_mode_str != NULL) {
            int  new_flash_mode = -1;

            if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_OFF))
                new_flash_mode = FLASH_MODE_OFF;
            else if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_AUTO))
                new_flash_mode = FLASH_MODE_AUTO;
            else if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_ON))
                new_flash_mode = FLASH_MODE_ON;
    #ifdef  NU_FLASH_CTRL_IOCTL
            else if (!strcmp(new_flash_mode_str, CameraParameters::FLASH_MODE_TORCH))
                new_flash_mode = FLASH_MODE_TORCH;
    #endif
            else {
                LOGE("%s::unmatched flash_mode(%s)", __func__, new_flash_mode_str); //red-eye
                ret = UNKNOWN_ERROR;
            }
			LOGV("JZYANG ret12 = %d", ret);
            if (0 <= new_flash_mode && new_flash_mode< FLASH_MODE_MAX ) {
                if (mNuCameraV4L2->setFlashMode(new_flash_mode) < 0) {
                    LOGE("%s::mNuCameraV4L2->setFlashMode(%d) fail", __func__, new_flash_mode);
                    ret = UNKNOWN_ERROR;
                } else {
                    mParameters.set(CameraParameters::KEY_FLASH_MODE, new_flash_mode_str);
                }
            }
        }
		LOGV("JZYANG ret13 = %d", ret);

        //  scene..
        if (0 <= new_scene_mode) {
            if (mNuCameraV4L2->setSceneMode(new_scene_mode) < 0) {
                LOGE("%s::mNuCameraV4L2->setSceneMode(%d) fail", __func__, new_scene_mode);
                ret = UNKNOWN_ERROR;
            } else {
                mParameters.set(CameraParameters::KEY_SCENE_MODE, new_scene_mode_str);
            }
        }
		LOGV("JZYANG ret14 = %d", ret);

    } else {
        if (!isSupportedParameter(new_focus_mode_str,
                    mParameters.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES))) {
            LOGE("%s: Unsupported focus mode: %s", __func__, new_focus_mode_str);
            ret = UNKNOWN_ERROR;
        }
    }
	LOGV("JZYANG ret15 = %d", ret);

    // ---------------------------------------------------------------------------

    // image effect

#if NUSMART_CAMERA_ISP_EFFECT

        const char *new_image_effect_str = params.get(CameraParameters::KEY_EFFECT);

        if (new_image_effect_str != NULL) {
			
            int  new_image_effect = -1;

            if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_NONE))
                new_image_effect = IMAGE_EFFECT_NONE;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_MONO))
                new_image_effect = IMAGE_EFFECT_MONO;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_SOLARIZE))
                new_image_effect = IMAGE_EFFECT_SOLARIZE;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_AQUA))
                new_image_effect = IMAGE_EFFECT_AQUA;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_NEGATIVE))
                new_image_effect = IMAGE_EFFECT_NEGATIVE;
           else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_SEPIA))
                new_image_effect = IMAGE_EFFECT_SEPIA;
            else {
                //posterize, whiteboard, blackboard, solarize
                LOGE("ERR(%s):Invalid effect(%s)", __func__, new_image_effect_str);
                ret = UNKNOWN_ERROR;
            }
			LOGI("set image effect : (%d)", new_image_effect);
            if (new_image_effect >= 0) {
                if (mNuCameraV4L2->setImageEffect(new_image_effect) < 0) {
                    LOGE("ERR(%s):Fail on mNuCameraV4L2->setImageEffect(effect(%d))", __func__, new_image_effect);
                    ret = UNKNOWN_ERROR;
                } else {
                    const char *old_image_effect_str = mParameters.get(CameraParameters::KEY_EFFECT);

                    if (old_image_effect_str) {
                        if (strcmp(old_image_effect_str, new_image_effect_str)) {
                            setSkipFrame(EFFECT_SKIP_FRAME);
                        }
                    }

                    mParameters.set(CameraParameters::KEY_EFFECT, new_image_effect_str);
                }
            }
        }//end image effect

#else
        const char *new_image_effect_str = params.get(CameraParameters::KEY_EFFECT);

        if (new_image_effect_str != NULL) {

            int  new_image_effect = -1;

            if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_NONE))
                new_image_effect = Effect::CAMERA_EFFECT_NONE;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_MONO))
                new_image_effect = Effect::CAMERA_EFFECT_MONO;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_SOLARIZE))
                new_image_effect = Effect::CAMERA_EFFECT_SOLARIZE;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_AQUA))
                new_image_effect = Effect::CAMERA_EFFECT_AQUA;
            else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_NEGATIVE))
                new_image_effect = Effect::CAMERA_EFFECT_NEGATIVE;
           else if (!strcmp(new_image_effect_str, CameraParameters::EFFECT_SEPIA))
                new_image_effect = Effect::CAMERA_EFFECT_SEPIA;
            else {
                //posterize, whiteboard, blackboard, solarize
                LOGE("ERR(%s):Invalid effect(%s)", __func__, new_image_effect_str);
                ret = UNKNOWN_ERROR;
            }

            if (new_image_effect >= 0) {
                if (mNuCameraV4L2->setImageEffect(new_image_effect) < 0) {
                    LOGE("ERR(%s):Fail on mNuCameraV4L2->setImageEffect(effect(%d))", __func__, new_image_effect);
                    ret = UNKNOWN_ERROR;
                } else {
                    const char *old_image_effect_str = mParameters.get(CameraParameters::KEY_EFFECT);

                    if (old_image_effect_str) {
                        if (strcmp(old_image_effect_str, new_image_effect_str)) {
                            setSkipFrame(EFFECT_SKIP_FRAME);
                        }
                    }

                    mParameters.set(CameraParameters::KEY_EFFECT, new_image_effect_str);
                }
            }
        }//end image effect

#endif

        //contrast
        int new_contrast = mInternalParameters.getInt("contrast");

        if (0 <= new_contrast) {
            if (mNuCameraV4L2->setContrast(new_contrast) < 0) {
                LOGE("ERR(%s):Fail on mNuCameraV4L2->setContrast(%d)", __func__, new_contrast);
                ret = UNKNOWN_ERROR;
            }
        }
		LOGV("JZYANG ret16 = %d", ret);

    // gps latitude
    const char *new_gps_latitude_str = params.get(CameraParameters::KEY_GPS_LATITUDE);
    if (mNuCameraV4L2->setGPSLatitude(new_gps_latitude_str) < 0) {
        LOGE("%s::mNuCameraV4L2->setGPSLatitude(%s) fail", __func__, new_gps_latitude_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_latitude_str) {
            mParameters.set(CameraParameters::KEY_GPS_LATITUDE, new_gps_latitude_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_LATITUDE);
        }
    }
	LOGV("JZYANG ret17 = %d", ret);

    // gps longitude
    const char *new_gps_longitude_str = params.get(CameraParameters::KEY_GPS_LONGITUDE);

    if (mNuCameraV4L2->setGPSLongitude(new_gps_longitude_str) < 0) {
        LOGE("%s::mNuCameraV4L2->setGPSLongitude(%s) fail", __func__, new_gps_longitude_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_longitude_str) {
            mParameters.set(CameraParameters::KEY_GPS_LONGITUDE, new_gps_longitude_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_LONGITUDE);
        }
    }
	LOGV("JZYANG ret18 = %d", ret);

    // gps altitude
    const char *new_gps_altitude_str = params.get(CameraParameters::KEY_GPS_ALTITUDE);

    if (mNuCameraV4L2->setGPSAltitude(new_gps_altitude_str) < 0) {
        LOGE("%s::mNuCameraV4L2->setGPSAltitude(%s) fail", __func__, new_gps_altitude_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_altitude_str) {
            mParameters.set(CameraParameters::KEY_GPS_ALTITUDE, new_gps_altitude_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_ALTITUDE);
        }
    }
	LOGV("JZYANG ret19 = %d", ret);

    // gps timestamp
    const char *new_gps_timestamp_str = params.get(CameraParameters::KEY_GPS_TIMESTAMP);

    if (mNuCameraV4L2->setGPSTimeStamp(new_gps_timestamp_str) < 0) {
        LOGE("%s::mNuCameraV4L2->setGPSTimeStamp(%s) fail", __func__, new_gps_timestamp_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_timestamp_str) {
            mParameters.set(CameraParameters::KEY_GPS_TIMESTAMP, new_gps_timestamp_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_TIMESTAMP);
        }
    }
	LOGV("JZYANG ret20 = %d", ret);

    // gps processing method
    const char *new_gps_processing_method_str = params.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);

    if (mNuCameraV4L2->setGPSProcessingMethod(new_gps_processing_method_str) < 0) {
        LOGE("%s::mNuCameraV4L2->setGPSProcessingMethod(%s) fail", __func__, new_gps_processing_method_str);
        ret = UNKNOWN_ERROR;
    } else {
        if (new_gps_processing_method_str) {
            mParameters.set(CameraParameters::KEY_GPS_PROCESSING_METHOD, new_gps_processing_method_str);
        } else {
            mParameters.remove(CameraParameters::KEY_GPS_PROCESSING_METHOD);
        }
    }
	LOGV("JZYANG ret21 = %d", ret);

    // Recording size
    int new_recording_width, new_recording_height;
    new_recording_width = 0;
    new_recording_height = 0;

	const char *set_mode_str = params.get(CameraParameters::KEY_SET_MODE);
	if(strcmp(set_mode_str, "view")) {
		new_recording_width = 640;
    	new_recording_height = 480;
	} else {
		new_recording_width = 1280;
    	new_recording_height = 720;
	}
//    params.getVideoSize(&new_recording_width, &new_recording_height);
    if (0 < new_recording_width && 0 < new_recording_height) {
        LOGV("%s, call Parameters.setVideoSize(%dx%d)", __func__, new_recording_width, new_recording_height);
        mNuCameraV4L2->setRecordingSize(new_recording_width, new_recording_height);
        mParameters.setVideoSize(new_recording_width, new_recording_height);
    } else {
        LOGE("ERR(%s): Wrong Record Resolution:%dx%d, relaced by preview resolution:%dx%d ", __func__,
        new_recording_width, new_recording_height, new_preview_width, new_preview_height);
        mNuCameraV4L2->setRecordingSize(new_preview_width, new_preview_height);
        mParameters.setVideoSize(new_preview_width, new_preview_height);
    }
    return ret;
}

CameraParameters NuCameraHardware::getParameters() const
{
    return mParameters;
}

status_t NuCameraHardware::sendCommand(int32_t command, int32_t arg1, int32_t arg2)
{
    return BAD_VALUE;
}

void NuCameraHardware::release()
{
    LOGV("%s", __func__);

    /* shut down any threads we have that might be running.  do it here
     * instead of the destructor.  we're guaranteed to be on another thread
     * than the ones below.  if we used the destructor, since the threads
     * have a reference to this object, we could wind up trying to wait
     * for ourself to exit, which is a deadlock.
     */
			if(mTarget != NULL){
			LOGD("zrl:mLooper->stop() and mTarget->releaseBuffers().");
			mLooper->stop();
			mLooper->unregisterHandler(mTarget->id());
			mTarget->releaseBuffers();
			mTarget.clear();
			}

    if (mPreviewThread != NULL) {
        /* this thread is normally already in it's threadLoop but blocked
         * on the condition variable or running.  signal it so it wakes
         * up and can exit.
         */
        mPreviewThread->requestExit();
        mExitPreviewThread = true;
        mPreviewRunning = true; /* let it run so it can exit */
        mPreviewCondition.signal();
        mPreviewThread->requestExitAndWait();
        mPreviewThread.clear();
    }
    if (mAutoFocusThread != NULL) {
        /* this thread is normally already in it's threadLoop but blocked
         * on the condition variable.  signal it so it wakes up and can exit.
         */
        mFocusLock.lock();
        mAutoFocusThread->requestExit();
        mExitAutoFocusThread = true;
        mFocusCondition.signal();
        mFocusLock.unlock();
        mAutoFocusThread->requestExitAndWait();
        mAutoFocusThread.clear();
    }

    if (mCaptureThread != NULL) {
        mCaptureThread->requestExitAndWait();
        mCaptureThread.clear();
    }

    if (mRawHeap) {
        mRawHeap->release(mRawHeap);
        mRawHeap = 0;
    }
    if (mPreviewHeap) {
        mPreviewHeap->release(mPreviewHeap);
        mPreviewHeap = 0;
    }
    if (mRecordHeap) {
        mRecordHeap->release(mRecordHeap);
        mRecordHeap = 0;
    }

     /* close after all the heaps are cleared since those
     * could have dup'd our file descriptor.
     */
    mNuCameraV4L2->DeinitCamera();
}

status_t NuCameraHardware::storeMetaDataInBuffers(bool enable)
{
    // FIXME:
    // metadata buffer mode can be turned on or off.
    // Samsung needs to fix this.
    return INVALID_OPERATION;

}

static bool isUsbOneCamera = false;

static CameraInfo sCameraInfo_one_usb[] = {
//for only insert one usb camera
    {
        CAMERA_FACING_BACK,
        0,  // orientation
    },
};

static CameraInfo sCameraInfo_one_isp[] = {
//for only insert isp camera
    {
        CAMERA_FACING_FRONT,
        0,  // orientation
    },
};

static CameraInfo sCameraInfo_two[] = {
//for insert two camera
	{
        CAMERA_FACING_BACK,
        //180,  // orientation
        0,  // orientation
    },

    {
        CAMERA_FACING_FRONT,
        0,  // orientation
    },
};

/** Close this device */

static camera_device_t *g_cam_device;

static int HAL_camera_device_close(struct hw_device_t* device)
{
    LOGI("%s", __func__);
    if (device) {
        camera_device_t *cam_device = (camera_device_t *)device;
        delete static_cast<NuCameraHardware *>(cam_device->priv);
        free(cam_device);
        g_cam_device = 0;
    }
    return 0;
}

static inline NuCameraHardware *obj(struct camera_device *dev)
{
    return reinterpret_cast<NuCameraHardware *>(dev->priv);
}

/** Set the preview_stream_ops to which preview frames are sent */
static int HAL_camera_device_set_preview_window(struct camera_device *dev,
                                                struct preview_stream_ops *buf)
{
    LOGV("%s", __func__);
    return obj(dev)->setPreviewWindow(buf);
}

/** Set the notification and data callbacks */
static void HAL_camera_device_set_callbacks(struct camera_device *dev,
        camera_notify_callback notify_cb,
        camera_data_callback data_cb,
        camera_data_timestamp_callback data_cb_timestamp,
        camera_request_memory get_memory,
        void* user)
{
    LOGV("%s", __func__);
    obj(dev)->setCallbacks(notify_cb, data_cb, data_cb_timestamp,
                           get_memory,
                           user);
}

/**
 * The following three functions all take a msg_type, which is a bitmask of
 * the messages defined in include/ui/Camera.h
 */

/**
 * Enable a message, or set of messages.
 */
static void HAL_camera_device_enable_msg_type(struct camera_device *dev, int32_t msg_type)
{
    //LOGV("%s", __func__);
    obj(dev)->enableMsgType(msg_type);
}

/**
 * Disable a message, or a set of messages.
 *
 * Once received a call to disableMsgType(CAMERA_MSG_VIDEO_FRAME), camera
 * HAL should not rely on its client to call releaseRecordingFrame() to
 * release video recording frames sent out by the cameral HAL before and
 * after the disableMsgType(CAMERA_MSG_VIDEO_FRAME) call. Camera HAL
 * clients must not modify/access any video recording frame after calling
 * disableMsgType(CAMERA_MSG_VIDEO_FRAME).
 */
static void HAL_camera_device_disable_msg_type(struct camera_device *dev, int32_t msg_type)
{
    //LOGV("%s", __func__);
    obj(dev)->disableMsgType(msg_type);
}

/**
 * Query whether a message, or a set of messages, is enabled.  Note that
 * this is operates as an AND, if any of the messages queried are off, this
 * will return false.
 */
static int HAL_camera_device_msg_type_enabled(struct camera_device *dev, int32_t msg_type)
{
    //LOGV("%s", __func__);
    return obj(dev)->msgTypeEnabled(msg_type);
}

/**
 * Start preview mode.
 */
static int HAL_camera_device_start_preview(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->startPreview();
}

/**
 * Stop a previously started preview.
 */
static void HAL_camera_device_stop_preview(struct camera_device *dev)
{
    LOGV("%s", __func__);
    obj(dev)->stopPreview();
}

/**
 * Returns true if preview is enabled.
 */
static int HAL_camera_device_preview_enabled(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->previewEnabled();
}

/**
 * Request the camera HAL to store meta data or real YUV data in the video
 * buffers sent out via CAMERA_MSG_VIDEO_FRAME for a recording session. If
 * it is not called, the default camera HAL behavior is to store real YUV
 * data in the video buffers.
 *
 * This method should be called before startRecording() in order to be
 * effective.
 *
 * If meta data is stored in the video buffers, it is up to the receiver of
 * the video buffers to interpret the contents and to find the actual frame
 * data with the help of the meta data in the buffer. How this is done is
 * outside of the scope of this method.
 *
 * Some camera HALs may not support storing meta data in the video buffers,
 * but all camera HALs should support storing real YUV data in the video
 * buffers. If the camera HAL does not support storing the meta data in the
 * video buffers when it is requested to do do, INVALID_OPERATION must be
 * returned. It is very useful for the camera HAL to pass meta data rather
 * than the actual frame data directly to the video encoder, since the
 * amount of the uncompressed frame data can be very large if video size is
 * large.
 *
 * @param enable if true to instruct the camera HAL to store
 *      meta data in the video buffers; false to instruct
 *      the camera HAL to store real YUV data in the video
 *      buffers.
 *
 * @return OK on success.
 */
static int HAL_camera_device_store_meta_data_in_buffers(struct camera_device *dev, int enable)
{
    LOGV("%s", __func__);
    return obj(dev)->storeMetaDataInBuffers(enable);
}

/**
 * Start record mode. When a record image is available, a
 * CAMERA_MSG_VIDEO_FRAME message is sent with the corresponding
 * frame. Every record frame must be released by a camera HAL client via
 * releaseRecordingFrame() before the client calls
 * disableMsgType(CAMERA_MSG_VIDEO_FRAME). After the client calls
 * disableMsgType(CAMERA_MSG_VIDEO_FRAME), it is the camera HAL's
 * responsibility to manage the life-cycle of the video recording frames,
 * and the client must not modify/access any video recording frames.
 */
static int HAL_camera_device_start_recording(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->startRecording();
}

/**
 * Stop a previously started recording.
 */
static void HAL_camera_device_stop_recording(struct camera_device *dev)
{
    LOGV("%s", __func__);
    obj(dev)->stopRecording();
}

/**
 * Returns true if recording is enabled.
 */
static int HAL_camera_device_recording_enabled(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->recordingEnabled();
}

/**
 * Release a record frame previously returned by CAMERA_MSG_VIDEO_FRAME.
 *
 * It is camera HAL client's responsibility to release video recording
 * frames sent out by the camera HAL before the camera HAL receives a call
 * to disableMsgType(CAMERA_MSG_VIDEO_FRAME). After it receives the call to
 * disableMsgType(CAMERA_MSG_VIDEO_FRAME), it is the camera HAL's
 * responsibility to manage the life-cycle of the video recording frames.
 */
static void HAL_camera_device_release_recording_frame(struct camera_device *dev,
                                const void *opaque)
{
    //LOGV("%s", __func__);
    obj(dev)->releaseRecordingFrame(opaque);
}

/**
 * Start auto focus, the notification callback routine is called with
 * CAMERA_MSG_FOCUS once when focusing is complete. autoFocus() will be
 * called again if another auto focus is needed.
 */
static int HAL_camera_device_auto_focus(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->autoFocus();
}

/**
 * Cancels auto-focus function. If the auto-focus is still in progress,
 * this function will cancel it. Whether the auto-focus is in progress or
 * not, this function will return the focus position to the default.  If
 * the camera does not support auto-focus, this is a no-op.
 */
static int HAL_camera_device_cancel_auto_focus(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->cancelAutoFocus();
}

/**
 * Take a picture.
 */
static int HAL_camera_device_take_picture(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->takePicture();
}

/**
 * Cancel a picture that was started with takePicture. Calling this method
 * when no picture is being taken is a no-op.
 */
static int HAL_camera_device_cancel_picture(struct camera_device *dev)
{
    LOGV("%s", __func__);
    return obj(dev)->cancelPicture();
}

/**
 * Set the camera parameters. This returns BAD_VALUE if any parameter is
 * invalid or not supported.
 */
static int HAL_camera_device_set_parameters(struct camera_device *dev,
                                            const char *parms)
{
    LOGV("%s", __func__);
    String8 str(parms);
    CameraParameters p(str);
    return obj(dev)->setParameters(p);
}

/** Return the camera parameters. */
char *HAL_camera_device_get_parameters(struct camera_device *dev)
{
    LOGV("%s, camera_deice(%p)", __func__, dev );
    String8 str;
    CameraParameters parms = obj(dev)->getParameters();
    str = parms.flatten();
    return strdup(str.string());
}

void HAL_camera_device_put_parameters(struct camera_device *dev, char *parms)
{
    LOGV("%s, camera_deice (%p)", __func__, dev);
    free(parms);
}

/**
 * Send command to camera driver.
 */
static int HAL_camera_device_send_command(struct camera_device *dev,
                    int32_t cmd, int32_t arg1, int32_t arg2)
{
    LOGV("%s", __func__);
    return obj(dev)->sendCommand(cmd, arg1, arg2);
}

/**
 * Release the hardware resources owned by this object.  Note that this is
 * *not* done in the destructor.
 */
static void HAL_camera_device_release(struct camera_device *dev)
{
    LOGV("%s", __func__);
    obj(dev)->release();
}

/**
 * Dump state of the camera hardware
 */
static int HAL_camera_device_dump(struct camera_device *dev, int fd)
{
    LOGV("%s", __func__);
    return obj(dev)->dump(fd);
}

static int HAL_getNumberOfCameras()
{
	int number;
	number = NuCameraV4L2::v4l2getNumberOfCameras(&isUsbOneCamera);
	LOGV("%s,mNumberOfCameras(%d), isUsbOneCamera(%d)",
		 __func__, number, isUsbOneCamera);
	
	return number;
    //return sizeof(sCameraInfo) / sizeof(sCameraInfo[0]);
}

static int HAL_getCameraInfo(int cameraId, struct camera_info *cameraInfo)
{
    LOGV("%s, cameraId(%d), isUsbOneCamera(%d)",
		 __func__, cameraId, isUsbOneCamera);
	
	if (2 == NuCameraV4L2::v4l2getNumberOfCameras(&isUsbOneCamera))
		memcpy(cameraInfo, &sCameraInfo_two[cameraId], sizeof(CameraInfo));
	else {
		if (isUsbOneCamera)
			memcpy(cameraInfo, &sCameraInfo_one_usb[cameraId], sizeof(CameraInfo));
		else 
			memcpy(cameraInfo, &sCameraInfo_one_isp[cameraId], sizeof(CameraInfo));
	}
    return 0;
}

#define SET_METHOD(m) m : HAL_camera_device_##m

static camera_device_ops_t camera_device_ops = {
        SET_METHOD(set_preview_window),
        SET_METHOD(set_callbacks),
        SET_METHOD(enable_msg_type),
        SET_METHOD(disable_msg_type),
        SET_METHOD(msg_type_enabled),
        SET_METHOD(start_preview),
        SET_METHOD(stop_preview),
        SET_METHOD(preview_enabled),
        SET_METHOD(store_meta_data_in_buffers),
        SET_METHOD(start_recording),
        SET_METHOD(stop_recording),
        SET_METHOD(recording_enabled),
        SET_METHOD(release_recording_frame),
        SET_METHOD(auto_focus),
        SET_METHOD(cancel_auto_focus),
        SET_METHOD(take_picture),
        SET_METHOD(cancel_picture),
        SET_METHOD(set_parameters),
        SET_METHOD(get_parameters),
        SET_METHOD(put_parameters),
        SET_METHOD(send_command),
        SET_METHOD(release),
        SET_METHOD(dump),
};

#undef SET_METHOD

static int HAL_camera_device_open(const struct hw_module_t* module,
                                  const char *id,
                                  struct hw_device_t** device)
{
    int cameraId = atoi(id);
	int RealNumberOfCamera = NuCameraV4L2::v4l2getNumberOfCameras(&isUsbOneCamera);
	LOGV("number of camera(%d)", RealNumberOfCamera);
	
    if (cameraId < 0 || cameraId >= RealNumberOfCamera) {
        LOGE("Invalid camera ID %s", id);
        return -EINVAL;
    }

	if (2 == RealNumberOfCamera) {
		cameraId = sCameraInfo_two[atoi(id)].facing;
	} else {
		if (isUsbOneCamera)
			cameraId = sCameraInfo_one_usb[atoi(id)].facing;
		else 
		    cameraId = sCameraInfo_one_isp[atoi(id)].facing;// not usb camera
	 }
	
    if (g_cam_device) {
        if (obj(g_cam_device)->getCameraId() == cameraId) {
            LOGE("returning existing camera ID %s", id);
            goto done;
        } else {
            LOGE("Cannot open camera %d. camera %d is already running!",
                    cameraId, obj(g_cam_device)->getCameraId());
            return -ENOSYS;
        }
    }

    g_cam_device = (camera_device_t *)malloc(sizeof(camera_device_t));
    if (!g_cam_device)
        return -ENOMEM;

    g_cam_device->common.tag     = HARDWARE_DEVICE_TAG;
    g_cam_device->common.version = 1;
    g_cam_device->common.module  = const_cast<hw_module_t *>(module);
    g_cam_device->common.close   = HAL_camera_device_close;

    g_cam_device->ops = &camera_device_ops;

    LOGI("%s: open camera %s", __func__, id);

    g_cam_device->priv = new NuCameraHardware(cameraId, g_cam_device);

done:
    *device = (hw_device_t *)g_cam_device;
    LOGI("%s: opened camera %s (%p)", __func__, id, *device);
    return 0;
}

static hw_module_methods_t camera_module_methods = {
            open : HAL_camera_device_open
};

extern "C" {
    struct camera_module HAL_MODULE_INFO_SYM = {
      common : {
          tag           : HARDWARE_MODULE_TAG,
          version_major : 1,
          version_minor : 0,
          id            : CAMERA_HARDWARE_MODULE_ID,
          name          : "NS115 camera HAL",
          author        : "Nufront Corporation",
          methods       : &camera_module_methods,
          dso:           NULL,
          reserved:      {0},
      },
      get_number_of_cameras : HAL_getNumberOfCameras,
      get_camera_info       : HAL_getCameraInfo
    };
}

bool NuCameraHardware::isPreviewTime()
{
	LOGV("%s", __func__);
    timeval cur_time;
    gettimeofday(&cur_time, NULL);
    const uint64_t cur_mks = cur_time.tv_sec * 1000000LL + cur_time.tv_usec;
    if ((cur_mks - mLastPreviewed) >= mPreviewAfter) {
        mLastPreviewed = cur_mks;
        return true;
    }
    return false;
}
}; // namespace android
